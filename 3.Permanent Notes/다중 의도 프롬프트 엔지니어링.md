---
title: "다중 의도 프롬프트 엔지니어링"
type: permanent
tags: [노트/영구, 주제/프롬프트-엔지니어링, 주제/LLM, 기술/다중-의도]
status: active
date: 2025-09-22
updated: 2025-09-22
---

생성형 AI가 사용자의 복잡한 다중 의도(Multi-intent) 요청을 처리하기 위한 기술적 접근법에 대한 아이디어. 단순 분류를 넘어, 추론을 통해 실행 계획을 수립하는 것이 핵심.

---

## 개인적 견해
이 문서는 생성형 AI 기반 챗봇에서 다중 의도를 처리하는 데 필요한 포괄적인 기술적 접근법을 제시합니다. 특히 전통적인 NLU의 '분류'에서 LLM의 '추론'으로 패러다임이 전환되었음을 명확히 설명하며, 프롬프트 엔지니어링, 아키텍처 패턴, 평가 프레임워크 등 실용적인 측면을 깊이 있게 다룹니다.

개인적으로 가장 인상 깊었던 부분은 '관리자-작업자 패턴'을 통해 LLM의 '대화 속 미아' 문제를 해결하는 아키텍처적 접근입니다. 이는 LLM의 한계를 시스템 설계로 극복하려는 현실적인 시도로 보이며, 복잡한 대화 시스템 구축 시 반드시 고려해야 할 중요한 원칙이라고 생각합니다. 또한, 하이브리드 시스템 설계는 비용 효율성과 성능을 동시에 잡을 수 있는 실용적인 방안으로, 실제 서비스 구현에 큰 도움이 될 것입니다.

## 연결점
- [[AI 에이전트 마케팅 시스템 - 설계 원리]] - AI 에이전트 시스템 설계 시 다중 의도 처리 아키텍처 적용 방안
- [[AI 프로젝트 성공 - 3요소 모델]] - AI 프로젝트 성공을 위한 기술적, 관리적, 평가적 요소와 이 문서의 내용 연결
- [[마케팅 자동화 - 3단계 프로세스]] - 마케팅 자동화 시스템에서 사용자 의도 처리의 중요성

---

## 1.다중 의도(Multi-Intent) 문제의 본질

- **패러다임 전환** : 전통적 NLU의 '다중 레이블 분류' 방식은 의도 간의 관계(순서, 조건)를 파악하지 못함. 생성형 AI는 이를 '추론' 문제로 전환하여, 실행 가능한 계획(execution plan)을 수립.
- **다중 의도 유형** :
  - **1) 병렬 의도 (Bundled)** : 독립적인 여러 요청(예: "날씨 알려주고 호텔 예약해 줘")
  - **2) 순차 의도 (Sequential)** : 요청 간 순서나 종속성 존재(예: "주문 상태 확인하고, 배송 시작됐으면 송장 번호 알려줘")
  - **3) 중첩 의도 (Nested)** : 주된 의도 내 하위 의도 포함(예: '자동차 구매' 내 '브랜드/모델 질문')
  - **4) 주제 전환 (Topic Switching)** : 대화 중 다른 주제로 전환
- 다음과 같은 구조화된 실행 계획(execution plan)을 생성 :**{"plan": [{"step": 1, "intent": "check_order"}, {"step": 2, "intent": "get_tracking", "dependency": "step_1.status == 'shipped'"}]}

## 2.기초 프롬프트 엔지니어링

- **핵심 구성 요소** :
  - **페르소나/역할 설정** : "당신은 요청을 작업으로 분해하는 전문가입니다."
  - **명확한 지침** : "모든 개별 의도를 식별하고 정보를 추출하십시오."
  - **사용 가능한 의도/도구 목록 제공** : 환각 방지 및 정확도 향상.
  - **퓨샷 예제 (Few-Shot)** : 고품질 예시를 2-3개 제공하여 원하는 출력 패턴 학습.
- **구조화된 출력 (JSON)** :
  - **JSON 출력 강제** : 프롬프트에 명시적으로 요청하고, API의 네이티브 JSON 모드(e.g., `response_format={"type": "json_object"}`)를 활용하여 항상 유효한 JSON을 보장.
  - **스키마 정의** : 출력 JSON의 구조(필수 필드, 데이터 타입 등)를 명확히 정의하여 일관성 극대화.
  - 예시:
    - **시스템 프롬프트 (System Prompt)**
```yaml
role: system
content: "당신은 사용자의 요청을 구조화된 작업 목록으로 분해하는 전문가입니다. 사용자 메시지를 분석하여 모든 의도를 식별하고, 아래에 정의된 JSON 스키마를 엄격히 준수하는 JSON 객체로만 응답하십시오. 다른 설명이나 부가적인 텍스트는 절대 포함하지 마십시오."
```
    - **API 요청 시 전달되는 JSON 스키마 (예: OpenAI 'tools' 파라미터)**
```json
{
  "tool_choice": {"type": "function", "function": {"name": "multi_intent_parser"}},
  "tools": [
    {
      "type": "function",
      "function": {
        "name": "parse_multi_intent_request",
        "description": "Parses a user's complex request into a list of structured intents.",
        "parameters": {
          "type": "object",
          "properties": {
            "intents": {
              "type": "array",
              "description": "List of identified intents.",
              "items": {
                "type": "object",
                "properties": {
                  "intent_name": {
                    "type": "string",
                    "description": "Name of the identified intent (e.g., 'get_weather', 'book_hotel')."
                  },
                  "parameters": {
                    "type": "object",
                    "description": "A key-value map of parameters (entities) required for the intent."
                  }
                },
                "required": ["intent_name", "parameters"]
              }
            }
          },
          "required": ["intents"]
        }
      }
    }
  ]
}
```
    - **예상되는 LLM의 구조화된 출력 (Assistant Response)**
```json
{
  "intents": [
    {
      "intent_name": "get_weather",
      "parameters": {
        "location": "London"
      }
    },
    {
      "intent_name": "book_hotel",
      "parameters": {
        "location": "London"
      }
    }
  ]
}
```

## 3.고급 프롬프팅 기법

- **생각의 사슬 (Chain-of-Thought, CoT)**:
  - 복잡한 문제의 중간 추론 과정을 단계별로 생성하도록 유도.
  - 의도 간 종속성, 순차적 실행 계획 수립에 효과적. (예: "단계별로 생각해 보자")
- **작업 분해 (Decomposed Prompting, DECOMP)**:
  - '분할 정복' 전략. 매우 복잡한 요청을 관리 가능한 하위 작업으로 명시적으로 나누도록 지시.
  - 병렬 처리 가능한 하위 문제 식별에 유용. (예: "여행 계획에 필요한 모든 하위 작업으로 분해해줘")
- LLM의 최종 구조화된 출력 (JSON):
```json
{
  "main_goal": "Plan a weekend trip to Paris",
  "sub_tasks": [
    {
      "task_id": 1,
      "intent": "find_flights",
      "parameters": {
        "destination": "Paris",
        "timeframe": "next month",
        "trip_type": "weekend"
      }
    },
    {
      "task_id": 2,
      "intent": "find_hotel",
      "parameters": {
        "location": "Paris",
        "duration": "weekend",
        "preferences": ["city_center"]
      }
    },
    {
      "task_id": 3,
      "intent": "suggest_activities",
      "parameters": {
        "location": "Paris",
        "interests": ["art museums", "food"]
      }
    }
  ]
}
```
## 4.아키텍처 패턴

- **함수 호출 (Function Calling / Tool Use)**:
  - 의도를 실제 코드(함수/도구)와 직접 연결.
  - **병렬 함수 호출**: 독립적인 여러 의도를 비동기적으로 동시에 실행하여 응답 시간 단축.
- **다중 에이전트 워크플로우**:
  - 시스템을 여러 전문 에이전트의 협력 체계로 구성.
  - '감독(Supervisor)' 에이전트가 요청을 분해하여 전문 '작업자(Worker)' 에이전트에게 라우팅.
  - 모듈성, 정확도, 확장성 향상. (e.g., LangGraph)

## 5.하이브리드 시스템 설계

- **목적**: 비용과 성능 최적화. 모든 요청을 LLM으로 처리하는 비효율성 개선.
- **아키텍처**:
  1.  **초기 NLU 분류**: 모든 요청은 먼저 경량 NLU 분류기를 통과.
  2.  **신뢰도 기반 라우팅**:
      - **고신뢰도 단일 의도**: LLM을 거치지 않고 바로 결정론적 로직으로 처리.
      - **저신뢰도/다중 의도**: LLM으로 에스컬레이션하여 정교한 분석 수행.
- **LLM의 역할**: NLU의 분석 결과를 컨텍스트로 받아 모호성을 해결하는 '스마트 부조종사'.

## 6.대화 흐름 관리

- **의도 우선순위 결정**: 비즈니스 규칙, LLM의 종속성 분석, 또는 사용자에게 직접 확인.
- **컨텍스트 전환 및 상태 관리**: '프레임' 개념을 도입한 세션 상태 관리를 통해 대화 중단 및 재개 시 정보 유지.
- **의도 충돌 해결**: 논리적 모순을 감지하고, 사용자에게 명확화를 요청하여 해결.

## 7.다중 턴 대화의 문제 극복

- **'대화 속 미아' 문제**: 긴 대화에서 초기 목표를 잊거나 문맥을 오해하는 경향.
  - **해결책 (관리자-작업자 패턴)**: '관리자'가 대화를 통해 명세를 완성하고, '작업자'는 정리된 명세만 받아 상태 없이(stateless) 작업을 수행.
- **유한한 컨텍스트 창 관리**: 대화 요약, 구조화된 메모리 시스템, RAG 등으로 해결.
- **환각 및 오류 전파 완화**: RAG를 통한 근거 제시, 검증의 사슬(Chain of Verification), 신뢰도 점수 활용.

## 8.평가 및 검증 프레임워크

- **단순 정확도의 한계**: 부분적으로 맞춘 예측을 0점으로 처리하는 문제.
- **다중 레이블 분류 지표**:
  - **완전 일치 비율 (Exact Match Ratio)**: 가장 엄격한 지표.
  - **해밍 점수/손실**: 개별 레이블 예측의 정확도.
  - **F1-점수 (마이크로/매크로/가중 평균)**: 정밀도와 재현율의 조화 평균. 데이터 불균형 시 유용.
  - **자카드 유사도**: 두 집합 간의 유사도 측정.
- **전체 시스템 평가**: 의도 탐지 정확도를 넘어 **작업 완료율**, **슬롯 필링 정확도** 등 비즈니스 지표와 연계하여 종합 평가.
- **다중 의도 시스템을 위한 평가 지표 요약**

| 지표명 | 정의 | 주요 용도 | 고려사항 |
|---|---|---|---|
| 완전 일치 비율 (Exact Match Ratio) | 예측된 레이블 집합이 실제 정답 집합과 완전히 일치하는 샘플의 비율 | 시스템이 사용자의 모든 요청을 완벽하게 이해했는지 엄격하게 평가할 때 | 부분적으로 맞춘 예측에 대해 점수를 주지 않아 지나치게 엄격할 수 있음. 단일 오류도 0점으로 처리됨. |
| 해밍 점수 (Hamming Score) | 개별 레이블 예측의 정확도 (참 긍정 및 참 부정 모두 고려) | 전체적인 레이블 예측 능력에 대한 일반적인 성능을 파악할 때 | 데이터 불균형 시 참 부정(True Negative)의 영향이 커져 성능을 오도할 수 있음. |
| 정밀도 (Precision) | 모델이 예측한 레이블 중 실제 정답인 레이블의 비율 | 거짓 양성(잘못된 의도 실행)을 최소화하는 것이 중요할 때 (예: 결제, 주문 취소) | 거짓 음성(사용자 의도 누락)을 측정하지 않음. |
| 재현율 (Recall) | 실제 정답 레이블 중 모델이 예측한 레이블의 비율 | 사용자의 요청을 하나도 놓치지 않는 것이 중요할 때 (예: 고객 지원) | 거짓 양성(불필요한 작업 수행)을 측정하지 않음. |
| F1-점수 (F1-Score) | 정밀도와 재현율의 조화 평균 | 정밀도와 재현율 간의 균형 잡힌 성능을 측정할 때, 특히 데이터 불균형이 있을 때 가장 일반적으로 사용됨. | 평균화 방식(마이크로, 매크로, 가중)에 따라 해석이 크게 달라지므로 목적에 맞게 선택해야 함. |
| 자카드 유사도 (Jaccard Similarity) | 예측 집합과 정답 집합의 교집합을 합집합으로 나눈 값 | 두 레이블 집합 간의 유사도를 직관적으로 측정하고 싶을 때 | F1-점수보다 덜 사용되지만, 집합 기반 유사도를 명확하게 보여줌. |
